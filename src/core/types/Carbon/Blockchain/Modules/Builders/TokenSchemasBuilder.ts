import { bytesToHex } from '../../../../../utils';
import { CarbonBinaryWriter } from '../../../../CarbonSerialization';
import { VmNamedVariableSchema } from '../../Vm/VmNamedVariableSchema';
import { VmStructSchema } from '../../Vm/VmStructSchema';
import { VmType, vmTypeFromString } from '../../Vm/VmType';
import { StandardMeta } from '../StandardMeta';
import { TokenSchemas } from '../TokenSchemas';

export class TokenSchemasJson {
  seriesMetadata: FieldType[];
  rom: FieldType[];
  ram: FieldType[];
}

export function parseTokenSchemasJson(json: string): TokenSchemasJson {
  const raw = JSON.parse(json) as Record<string, unknown>

  const pickArray = (k: 'seriesMetadata' | 'rom' | 'ram') => {
    const arr = raw[k]
    if (!Array.isArray(arr)) throw new Error(`${k} must be an array`)
    return arr.map((it: any): FieldType => {
      if (typeof it?.name !== 'string') throw new Error(`${k} field name must be string`)
      if (typeof it?.type !== 'string') throw new Error(`${k} field type must be string`)
      return { name: it.name, type: vmTypeFromString(it.type) }
    })
  }

  return {
    seriesMetadata: pickArray('seriesMetadata'),
    rom: pickArray('rom'),
    ram: pickArray('ram'),
  }
}

export class FieldType {
  name: string;
  type: VmType;
}

export class TokenSchemasBuilder {
  public static seriesDefaultMetadataFields: readonly FieldType[] = [
    { name: StandardMeta.id.data, type: VmType.Int256 }, // Mandatory field, autogenerated by SDK
    { name: 'mode', type: VmType.Int8 },
    { name: 'rom', type: VmType.Bytes }
  ] as const;

  public static nftDefaultMetadataFields: readonly FieldType[] = [
    { name: StandardMeta.id.data, type: VmType.Int256 }, // Mandatory field, autogenerated by SDK
    { name: 'rom', type: VmType.Bytes }
  ] as const;

  public static standardMetadataFields: readonly FieldType[] = [
    { name: 'name', type: VmType.String },
    { name: 'description', type: VmType.String },
    { name: 'imageURL', type: VmType.String },
    { name: 'infoURL', type: VmType.String },
    { name: 'royalties', type: VmType.Int32 }
  ] as const;

  private static assertMetadataField(schemas: VmStructSchema[], fieldTypes: readonly FieldType[]): Readonly<{ ok: boolean, error: string | null }> {
    fieldTypes.forEach(fieldType => {
      let fieldIsFound: boolean = false;
      schemas.forEach(schema => {
        const found = schema.fields.find(x => x.name.data === fieldType.name);
        if (found != undefined) {
          if (found.schema.type != fieldType.type) {
            return { ok: false, error: `Type mismatch for ${fieldType.name} field, must be ${found.schema.type} instead of ${fieldType}` };
          }
          fieldIsFound = true;
        } else {
          const found2 = schema.fields.find(x => x.name.data.toLowerCase() === fieldType.name.toLowerCase())
          if (found2 != undefined) {
            return { ok: false, error: `Case mismatch for ${fieldType.name} field, must be ${found2.name}` };
          }
        }
      });

      if (!fieldIsFound) {
        return { ok: false, error: `Mandatory metadata field not found: ${fieldType.name}` };
      }
    });

    return { ok: true, error: null };
  }

  private static defaultSeriesSchema(sharedMetadata: boolean): VmStructSchema {
    // Series metadata schema
    const schema = new VmStructSchema();
    schema.fields = [];
    {
      // Default fields
      this.seriesDefaultMetadataFields.forEach(f => {
        schema.fields.push(new VmNamedVariableSchema(f.name, f.type));
      });

      if (sharedMetadata) {
        this.standardMetadataFields.forEach(f => {
          schema.fields.push(new VmNamedVariableSchema(f.name, f.type));
        });
      }
    }

    return schema;
  }

  private static defaultNftRomSchema(sharedMetadata: boolean): VmStructSchema {
    // NFT ROM schema
    const schema = new VmStructSchema();
    schema.fields = [];
    {
      // Default fields
      this.nftDefaultMetadataFields.forEach(f => {
        schema.fields.push(new VmNamedVariableSchema(f.name, f.type));
      });

      if (!sharedMetadata) {
        // They are default for all NFTs
        this.standardMetadataFields.forEach(f => {
          schema.fields.push(new VmNamedVariableSchema(f.name, f.type));
        });
      }
    }

    return schema;
  }

  private static seriesSchemaFromFieldTypes(fieldTypes: FieldType[]): VmStructSchema {
    // Series metadata schema
    const schema = new VmStructSchema();
    schema.fields = [];
    {
      // Default fields. Adding them always
      this.seriesDefaultMetadataFields.forEach(f => {
        schema.fields.push(new VmNamedVariableSchema(f.name, f.type));
      });

      fieldTypes.forEach(f => {
        schema.fields.push(new VmNamedVariableSchema(f.name, f.type));
      });
    }

    return schema;
  }

  private static nftRomSchemaFromFieldTypes(fieldTypes: FieldType[]): VmStructSchema {
    // NFT ROM schema
    const schema = new VmStructSchema();
    schema.fields = [];
    {
      // Default fields. Adding them always
      this.nftDefaultMetadataFields.forEach(f => {
        schema.fields.push(new VmNamedVariableSchema(f.name, f.type));
      });

      fieldTypes.forEach(f => {
        schema.fields.push(new VmNamedVariableSchema(f.name, f.type));
      });
    }

    return schema;
  }

  private static nftRamSchemaFromFieldTypes(fieldTypes: FieldType[]): VmStructSchema {
    if (fieldTypes.length == 0) {
      return new VmStructSchema([], VmStructSchema.Flags.DynamicExtras);
    }

    // RAM schema
    const schema = new VmStructSchema();
    schema.fields = [];
    {
      fieldTypes.forEach(f => {
        schema.fields.push(new VmNamedVariableSchema(f.name, f.type));
      });
    }

    return schema;
  }

  static prepareStandard(sharedMetadata: boolean): TokenSchemas {
    const tokenSchemas = new TokenSchemas();

    // Token's series metadata schema
    tokenSchemas.seriesMetadata = this.defaultSeriesSchema(sharedMetadata);

    // NFT's ROM schema
    tokenSchemas.rom = this.defaultNftRomSchema(sharedMetadata);

    // NFT's RAM schema
    tokenSchemas.ram = new VmStructSchema([], VmStructSchema.Flags.DynamicExtras);

    return tokenSchemas;
  }

  static fromJson(json: string): TokenSchemas {
    const tokenSchemasJson = parseTokenSchemasJson(json);

    const tokenSchemas = new TokenSchemas();
    tokenSchemas.seriesMetadata = this.seriesSchemaFromFieldTypes(tokenSchemasJson.seriesMetadata);
    tokenSchemas.rom = this.nftRomSchemaFromFieldTypes(tokenSchemasJson.rom);
    tokenSchemas.ram = this.nftRamSchemaFromFieldTypes(tokenSchemasJson.ram);

    const { ok, error } = this.verify(tokenSchemas);
    if (!ok) {
      throw Error(error ?? "Unknown error");
    }

    return tokenSchemas;
  }

  static verify(schemas: TokenSchemas): Readonly<{ ok: boolean, error: string | null }> {
    let result = this.assertMetadataField([schemas.seriesMetadata, schemas.rom], this.standardMetadataFields);
    if (!result.ok) {
      return result;
    }

    result = this.assertMetadataField([schemas.seriesMetadata], this.seriesDefaultMetadataFields);
    if (!result.ok) {
      return result;
    }

    result = this.assertMetadataField([schemas.rom], this.nftDefaultMetadataFields);
    if (!result.ok) {
      return result;
    }

    return { ok: true, error: null };
  }

  static serialize(tokenSchemas: TokenSchemas): Readonly<Uint8Array> {
    const schemaBuf = new CarbonBinaryWriter();
    tokenSchemas.write(schemaBuf);

    return schemaBuf.toUint8Array();
  }

  static serializeHex(tokenSchemas: TokenSchemas): Readonly<string> {
    return bytesToHex(this.serialize(tokenSchemas));
  }

  static logSchema(schema: VmStructSchema) {
    schema.fields.forEach(f => console.log("Schema field: ", f.name.data));
  }
}
